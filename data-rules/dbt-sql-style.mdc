---
alwaysApply: true
---
# dbt SQL Style Rules

These rules codify the organization's `dbt_style_guide (2).md` standards for every `*.sql` model, macro, snapshot, or seed query. They assume Snowflake as the primary warehouse, but remain warehouse-agnostic for general formatting.

## 1. General Formatting

* **Keywords vs identifiers:** SQL keywords and boolean operators are UPPERCASE; field and function names stay lowercase `snake_case`.
* **Trailing commas:** Keep commas at the end of each line to avoid editor diffs and align with dbt Cloud + Snowflake UI auto-formatters.
* **Indentation:** Use four spaces for indentation. When writing predicates, align them with the `where` keyword instead of adding an extra indent.
* **Line length:** Target ≤80 characters per line. Break long expressions or arrays onto multiple lines.
* **`as` for aliases:** Always include the `as` keyword when aliasing columns or expressions.
* **Newlines over cleverness:** Favor additional newlines/comments over compressed logic. Readability > fewer lines.

## 2. CTE Structure

* Declare every `{{ ref() }}` or `{{ source() }}` call inside a descriptive CTE at the top of the file.
* Each CTE performs a single, logical unit of work. If logic feels duplicated across models, promote it to its own model or macro.
* Include inline comments for complex or notable logic, especially when mirroring source quirks.
* Finish with a `final` (or equivalent) CTE and `select * from final` to simplify debugging without editing downstream references.
* Example scaffold:

```sql
with

events as (

    select * from {{ ref('events') }}

),

-- Describe why filtering is necessary
filtered_events as (

    select *
    from events
    where status = 'active'

)

select * from filtered_events
```

## 3. Query Organization

* Non-aggregate fields precede aggregates/window functions in the `select` list.
* Push filters and aggregations as early as practical to trim data volume before expensive joins/windowing.
* When selecting from more than one table, prefix every column with its alias to avoid ambiguity in reviewers or automated lineage tools.
* For `order by` / `group by`, reference column names (or use dbt-utils helpers) rather than positional ordinals.
* Prefer `union all` to `union` unless you explicitly need duplicate elimination.

## 4. Join Discipline

* Use `join` (implicit inner join) for equi-joins; reserve `left join` as the default when enforcing dimensional completeness.
* Avoid `right join`—pick the table you want fully preserved and list it in the `from` clause.
* Always list the "left" table (the driving table) in the `from` clause, followed by joins ordered by business relevance.
* Align join predicates beneath the `on` keyword to emphasize join keys and reduce accidental cross-joins.

## 5. dbt-Specific Notes

* **Layer Dependencies:**

  **Medallion Architecture:**
  * `raw_` models may select directly from `sources` defined in `sources.yml`.
  * `int_` models must use `{{ ref('raw_*') }}` to reference raw layer.
  * `anl_` models must use `{{ ref('int_*') }}` to reference integration layer.
  * Never skip layers (e.g., `anl_` models cannot reference `raw_` directly).

  **Traditional 5-Layer Architecture:**
  * `dl_` models may select directly from `sources` defined in `sources.yml` (cloud storage) or use `{{ ref() }}` for other DL models.
  * `stg_` models reference `sources` only (Fivetran-landed data) - no materialization.
  * `ods_` models may select from `sources` or use `{{ ref('dl_*') }}` / `{{ ref('stg_*') }}` to reference DL/STG layers.
  * `dw_` models must use `{{ ref('ods_*') }}` to reference ODS layer.
  * `bi_` models must use `{{ ref('dw_*') }}` to reference DW layer.
  * Never skip layers (e.g., `dw_` models cannot reference `dl_` or `stg_` directly; `bi_` models cannot reference `ods_` directly).

* **Model Naming:** Follow layer prefixes with double underscore `__` delimiters for party/system/subject area segments:
  * **Medallion:** `raw_`, `int_`, `anl_` (e.g., `raw_acme__salesforce__account`, `int_sales__customer`, `anl_sales__fact_orders`)
  * **Traditional:** `dl_`, `stg_`, `ods_`, `dw_`, `bi_` (e.g., `ods__netsuite__accounts`, `dw__finance__fact_transactions`, `bi__sales__monthly_summary`)

* **Snapshots:** Snapshot SQL should mirror these conventions; if duplicating logic across snapshots and models, refactor into macros.

* **Documentation:** Keep model headers (change log, developer, purpose) in YAML, not inline SQL comments, to centralize documentation.
