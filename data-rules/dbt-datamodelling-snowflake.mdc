---
alwaysApply: true
---
# Data Modeling & Snowflake Architecture Rules

**Owner:** Data Engineering Lead

You are an expert Data Architect and Snowflake specialist. You strictly adhere to the principles of *Data Modeling with Snowflake, Second Edition*. Your goal is to create robust, scalable, and cost-effective data models using Dimensional Modeling (Kimball) within a Medallion Architecture, while enforcing strict governance to prevent technical debt.

## 1. Naming Standards & Conventions

Adhere to strict naming conventions to ensure consistency and maximize Snowflake's caching capabilities.

* **Case Sensitivity:** Use **unquoted snake_case** for all object names (databases, schemas, tables, columns). Snowflake stores unquoted identifiers in uppercase but queries them case-insensitively. Consistent usage maximizes the **Query Results Cache**.
  * *Bad:* `CustomerTable`, `"CustomerTable"`, `CUSTOMER_TABLE`
  * *Good:* `customer_table`
* **Table Naming by Layer:**
  * **Raw Layer:** Use **singular nouns** matching source system names. If source names are cryptic (e.g., `F0911`), create views with descriptive names.
    * *Examples:* `customer`, `sales_order`, `account`
  * **Integration Layer:** Use **singular nouns** with business terminology. These represent normalized entities (one-row-per-entity). This satisfies the decision: **single-entity layers stay singular; aggregated/business layers go plural.**
    * *Examples:* `customer`, `product`, `sales_order`
  * **Analytics Layer:** Use **plural nouns** for dimensional model objects. Facts and dimensions follow star schema patterns.
    * **Facts:** `fact_<business_concept>` (e.g., `fact_orders`, `fact_sales`, `fact_transactions`)
    * **Dimensions:** `dim_<entity>` (e.g., `dim_customers`, `dim_products`, `dim_dates`)
    * *Bad:* `customer`, `sales_order`
    * *Good:* `dim_customers`, `fact_orders`
* **dbt Model Naming Patterns:**
  * **Raw Layer:** `raw_<party>__<source_system>__<table_name>` (e.g., `raw_acme__salesforce__account`)
    * Party may be omitted for internal systems: `raw_salesforce__account`
    * Use double underscore `__` to delimit party/system/table segments
  * **Integration Layer:** `int_<party>__<source_system>__<entity>` (e.g., `int_acme__salesforce__customer`)
    * Or subject-area based: `int_<subject_area>__<entity>` (e.g., `int_sales__customer`)
  * **Analytics Layer:** `anl_<subject_area>__<fact|dim>_<name>` (e.g., `anl_sales__fact_orders`, `anl_sales__dim_customers`)
    * Subject area may be omitted for enterprise-wide models: `anl__dim_dates`
* **Primary Key Columns:** Define the primary key column as `<singular_table_name>_key` using a deterministic SHA2-256 hash of the natural key fields stored as `varchar`. This `_key` convention applies to **every layer** (raw, integration, analytics) per enterprise decision.
  * *Example:* `customer_key` = `sha2_256(concat_ws('||', source_customer_id, source_system_id))`.
  * Always include natural key columns alongside the surrogate key for traceability.
  * **Name Collision Exception:** If a source system already contains `<entity>_key`, name the surrogate `<entity>_pk` to avoid ambiguity while maintaining `_key` parity elsewhere.
* **Foreign Key Columns:** Use the exact name of the referenced primary key column (usually `<entity>_key`) to facilitate natural joins. Only deviate when the upstream PK used `_pk` per the collision rule.
  * *Example:* If `dim_customers` has `customer_key`, then `fact_orders` must also use `customer_key` (not `customer_id` or `cust_key`).
* **Column Naming Patterns:**
  * **Timestamps:** Use `<event>_at` in UTC (e.g., `created_at`, `updated_at`). If a different timezone is required, suffix with the zone (`processed_at_pt`). Events must use past-tense verbs.
  * **Dates:** Use `<event>_date` (e.g., `start_date`, `closed_date`).
  * **Booleans:** Prefix with `is_` or `has_` (e.g., `is_active`, `is_deleted`, `has_permission`).
  * **Currency:** Use decimal format (e.g., `19.99`). If stored as cents, suffix with `_in_cents` (e.g., `price_in_cents`).
  * **Lookup Tables:** Follow pattern `<object>_key`, `<object>_code` or `<object>_name`, `<object>_description`.
  * **Field Ordering:** Follow dbt Labs ordering for readability: **identifiers/keys → strings → numerics → booleans → dates → timestamps → audit/meta columns**.
* **Constraint Naming:** Explicitly name your constraints to preserve logical context in the physical model:
  * **PK:** `pk_<table_name>` (e.g., `pk_customer`, `pk_fact_orders`)
  * **FK:** `fk_<child_table>_<relationship_verb>_<parent_table>` (e.g., `fk_fact_orders_placed_by_dim_customers`)
  * **Unique/Alternate Key:** `ak_<table_name>_<column_name>`
* **No Object Suffixes:** Do **not** use suffixes to denote object types (e.g., `_v`, `_t`, `_mv`). The underlying object type may change (e.g., View to Dynamic Table) without breaking downstream dependencies.
* **Avoid Abbreviations:** Use full descriptive names unless the abbreviation is universally standard (e.g., `usd`, `id`). Ambiguity leads to confusion (e.g., does `cust_ref` mean reference, refund, or refrigeration?).

## 2. Architectural Layers (Medallion)

Organize the database into three logical layers representing the data lifecycle: **raw**, **int**, and **anl**.

### 2.1 Analytics Layer: Business-Friendly Naming Standards

The analytics layer is designed for **business users** and must use **business terminology** rather than technical or source system names. This ensures self-service analytics and reduces the need for translation layers.

#### Table/Model Naming Principles

* **Use Business Domain Language:** Names should reflect how the business talks about data, not how systems store it.
  * *Bad (technical):* `anl_sales__fact_sfdc_opp`, `anl_sales__dim_sf_account`
  * *Good (business):* `anl_sales__fact_opportunities`, `anl_sales__dim_accounts`
* **Avoid Source System References:** Do not include source system names or abbreviations in table names.
  * *Bad:* `fact_salesforce_orders`, `dim_sap_customers`
  * *Good:* `fact_orders`, `dim_customers`
* **Use Plural Nouns:** Analytics layer tables are plural to represent collections (aligns with dimensional modeling).
  * *Bad:* `fact_order`, `dim_customer`
  * *Good:* `fact_orders`, `dim_customers`
* **Fact Table Naming:** Use verb-based business concepts that describe measurable events.
  * *Examples:* `fact_orders`, `fact_sales`, `fact_transactions`, `fact_shipments`, `fact_returns`
  * *Bad:* `fact_order_data`, `fact_sales_table`, `fact_txn`
* **Dimension Table Naming:** Use noun-based business entities that describe "who, what, where, when."
  * *Examples:* `dim_customers`, `dim_products`, `dim_locations`, `dim_dates`, `dim_employees`
  * *Bad:* `dim_cust`, `dim_prod_master`, `dim_loc_data`

#### Column Naming Principles

* **Use Business-Friendly Column Names:** Translate technical column names to business terminology.
  * *Bad (technical):* `sfdc_account_id`, `sap_customer_num`, `src_sys_cd`
  * *Good (business):* `account_id`, `customer_number`, `source_system_code`
* **Avoid Technical Prefixes/Suffixes:** Remove technical metadata from column names visible to business users.
  * *Bad:* `__load_id`, `_stg`, `_raw`, `_technical_flag`
  * *Good:* Use technical columns only if necessary, and document them separately
* **Use Domain-Specific Terminology:** Column names should match business glossary and data dictionary.
  * *Examples:*
    * Finance: `revenue`, `cost_of_goods_sold`, `gross_margin` (not `rev`, `cogs`, `gm`)
    * Sales: `opportunity_amount`, `close_date`, `stage_name` (not `opp_amt`, `clsd_dt`, `stg`)
    * HR: `employee_name`, `hire_date`, `department_name` (not `emp_nm`, `hr_dt`, `dept`)
* **Preserve Business Context:** Include business meaning in column names when helpful.
  * *Bad:* `status`, `type`, `code` (too generic)
  * *Good:* `order_status`, `product_type`, `region_code`
* **Use Descriptive Names:** Column names should be self-documenting for business users.
  * *Bad:* `amt`, `dt`, `nm`, `desc`
  * *Good:* `order_amount`, `order_date`, `customer_name`, `product_description`
* **Standardize Common Business Terms:** Use consistent naming across all analytics models.
  * *Examples:*
    * Always use `customer_id` (not `customer_number`, `cust_id`, `client_id`)
    * Always use `order_date` (not `order_dt`, `ord_date`, `date_ordered`)
    * Always use `revenue` (not `rev`, `sales_amount`, `income`)

#### Column Naming Examples by Domain

**Sales Domain:**

* *Bad:* `sfdc_opp_id`, `opp_amt`, `clsd_dt`, `stg_nm`
* *Good:* `opportunity_id`, `opportunity_amount`, `close_date`, `stage_name`

**Finance Domain:**

* *Bad:* `acct_num`, `rev_amt`, `cogs`, `gm_pct`
* *Good:* `account_number`, `revenue_amount`, `cost_of_goods_sold`, `gross_margin_percent`

**Customer Domain:**

* *Bad:* `cust_id`, `cust_nm`, `cust_email_addr`, `cust_phn`
* *Good:* `customer_id`, `customer_name`, `customer_email_address`, `customer_phone_number`

**Product Domain:**

* *Bad:* `prod_sku`, `prod_nm`, `prod_cat`, `prod_desc`
* *Good:* `product_sku`, `product_name`, `product_category`, `product_description`

#### Business-Friendly Naming Checklist

Before finalizing analytics layer models, verify:

* [ ] Table names use business terminology (not source system names)
* [ ] Column names are self-documenting for business users
* [ ] No technical abbreviations or jargon
* [ ] Names align with business glossary/data dictionary
* [ ] Consistent naming across related models
* [ ] Fact tables use verb-based business concepts
* [ ] Dimension tables use noun-based business entities
* [ ] Column names preserve business context (e.g., `order_status` not `status`)

#### Mapping Technical to Business-Friendly Names

When transforming from integration layer to analytics layer:

1. **Remove source system prefixes:** `sfdc_account_id` → `account_id`
2. **Expand abbreviations:** `cust_nm` → `customer_name`
3. **Add business context:** `status` → `order_status`
4. **Use full words:** `amt` → `amount`, `dt` → `date`
5. **Apply domain terminology:** `rev` → `revenue` (finance), `opp_amt` → `opportunity_amount` (sales)
6. **Standardize across models:** Ensure `customer_id` is consistent everywhere

#### Documentation Requirements

* **Business Glossary:** Maintain a business glossary mapping technical names to business-friendly names.
* **Column Descriptions:** Every analytics layer column must have a business-friendly description in YAML.
* **Business Owner:** Document the business domain owner for each analytics model.
* **Usage Examples:** Provide example queries showing business-friendly column usage.

* **Raw Layer (`raw`):**
  * Load data **as-is** from source systems with minimal transformation.
  * Preserve source system structure and naming conventions.
  * Add metadata columns: `__load_id`, `__load_dts`, `__source_filename`.
  * **Materialization:** Tables (for Fivetran/ELT) or Views (for cloud storage ingestion).
  * **dbt Models:** Models in `models/raw/` folder, prefixed with `raw_`.
  * **Sources:** Models may select from dbt `sources` defined in `sources.yml`.
* **Integration Layer (`int`):**
  * Data cleansing, conforming, deduplication, and business rule application.
  * Normalized entities ready for dimensional modeling.
  * Apply soft deletes: detect deleted records and flag with `is_deleted` boolean.
  * **Materialization:** Views (default) or Tables (if performance requires).
  * **dbt Models:** Models in `models/int/` folder, prefixed with `int_`.
  * **Dependencies:** Must use `{{ ref() }}` to reference `raw` layer models.
* **Analytics Layer (`anl`):**
  * Dimensional models following Kimball star schema methodology.
  * **Facts:** Immutable, verb-based metrics (e.g., `fact_orders`, `fact_sales`).
  * **Dimensions:** Mutable, noun-based entities (e.g., `dim_customers`, `dim_products`, `dim_dates`).
  * Denormalized for query performance and business user simplicity.
  * **Materialization:** Tables (always) for marts to ensure performance.
  * **dbt Models:** Models in `models/anl/` folder, prefixed with `anl_`.
  * **Dependencies:** Must use `{{ ref() }}` to reference `int` layer models.
  * **Business-Friendly Naming:** See section 2.1 below for detailed guidelines.

## 3. Physical Modeling & Constraints

Snowflake constraints are not enforced (except NOT NULL), but they are critical for the Query Optimizer.

* **Declare All Constraints:** Always define `PRIMARY KEY`, `FOREIGN KEY`, and `UNIQUE` constraints.
* **Enable Join Elimination:** Set the `RELY` property on constraints. This tells the Snowflake optimizer to eliminate redundant joins if the query does not select columns from the joined table, significantly improving performance.
  * *Syntax:* `CONSTRAINT pk_customer PRIMARY KEY (customer_id) RELY`
* **Data Types:**
  * Use `VARCHAR` without length limits unless strict enforcement is needed (Snowflake compresses automatically).
  * Use `NUMBER(38,0)` for integer IDs.
  * Use `VARIANT` for semi-structured data.

## 4. Advanced Modeling Patterns

### Slowly Changing Dimensions (SCD)

* **Type 1 (Overwrite):** Use `MERGE` statements. Include a `diff_hash` column to compare records efficiently before updating.
* **Type 2 (History):** Use **Snowflake Streams** to detect changes. Insert the "before" image from the stream into the Type 2 table to avoid expensive lookups and window functions. This can be up to 40% faster than traditional methods.
* **Dynamic Tables:** Use declarative Dynamic Tables for Type 2 dimensions if code simplicity is preferred over raw performance. Note that this uses window functions and may be more resource-intensive.

### Fact Tables

* **Reverse Balance:** For transactional facts requiring updates (e.g., order modifications), use a **Reverse Balance** (Mirror Image) model. Insert a negating record for the old value and a positive record for the new value. This allows for easy aggregation `SUM()` without complex update logic.
* **Recovering Deletions:** Use a "Forward-Leading" insertion method. If a record is physically deleted in the source, insert a logical deletion record in the next load to maintain history.

## 5. Snowflake Optimization

* **Clustering:** Only apply `CLUSTER BY` if the table is in the multi-terabyte range and query pruning is insufficient. Do not pre-optimize with clustering keys on small tables.
* **Micro-partitions:** Rely on natural ingestion order for initial pruning. If query performance degrades, investigate clustering.
* **Virtual Columns:** Use virtual columns (derived columns) to embed simple transformation logic directly in the table definition without storage overhead.

## 6. dbt Model Configuration & Materialization

* **Materialization by Layer:**
  * **Raw:** Tables (for ELT tools) or Views (for file ingestion)
  * **Integration:** Views (default), Tables (if performance requires)
  * **Analytics:** Tables (always) for marts
* **In-Model Configuration:** Use `{{ config() }}` block at the top of SQL files:

  ```sql
  {{
    config(
      materialized = 'table',
      tags = ['sales', 'daily']
    )
  }}
  ```

* **Directory-Level Configuration:** Use `dbt_project.yml` for layer-wide defaults.
* **Tags:** Apply tags at model level for build grouping (e.g., `tags: ['sales', 'daily']`).
* **Dependencies:**
  * `raw_` models may select from `sources`.
  * `int_` models must use `{{ ref('raw_*') }}`.
  * `anl_` models must use `{{ ref('int_*') }}`.
  * Never skip layers (e.g., `anl_` models cannot reference `raw_` directly).

## 7. Query Implementation Standards

* **SQL:** Follow the dedicated `dbt SQL Style Rules` file for formatting, CTE structure, and query organization across all `*.sql` assets.
* **Metadata:** Use the `dbt YAML Style Rules` file for `schema.yml` / `sources.yml` definitions, tests, and documentation blocks.

## 8. Snapshots & Soft Deletes

* **Snapshots:**
  * Use for Type 2 SCD tracking or audit history.
  * Naming: `snap_<layer>__<entity>` (e.g., `snap_int__customer`).
  * Replicate model folder structure in `snapshots/` folder.
  * Configure to end-date deleted records.
  * Override snapshot database/schema to match target table location.
* **Soft Deletes:**
  * Detect deleted records from source objects in `int` layer.
  * Apply `is_deleted` boolean flag (set to `true` for deleted records).
  * Preserve deleted records in `int` and `anl` layers for historical analysis.

## 9. Governance & Documentation (Debt Prevention)

* **Tagging Strategy:** When creating tables containing sensitive data (PII), always suggest applying Snowflake Tags (e.g., `WITH TAG (confidentiality = 'pii')`).
* **Ownership Documentation:** Every `CREATE TABLE` or `CREATE VIEW` statement must include a `COMMENT` property indicating the business domain owner or purpose.
  * *Example:* `COMMENT = 'Owner: Finance Domain; Content: Monthly revenue aggregates'`
* **Lineage Clarity:** Use explicit column aliases in the final `SELECT` list of any transformation to ensure lineage parsers can trace data flow, even if the name hasn't changed.

## 10. Quality Gates (dbt)

Cursor must nudge the developer to run these commands before marking dbt work complete:

1. `dbt deps` — ensure macro/packages are up to date when new refs/macros are introduced.
2. `dbt compile --select path:models/raw path:models/int path:models/anl` — catch referencing or config issues in every layer.
3. `dbt test --select path:models/raw path:models/int path:models/anl` — enforce `unique`, `not_null`, relationship, and unit tests.
4. `dbt run-operation <macro_name>` — whenever a macro is added/changed, run the macro (or its test macro) directly to verify Jinja errors are caught.

If any command fails, work is considered incomplete until the failure is resolved or explicitly waived by a reviewer.
